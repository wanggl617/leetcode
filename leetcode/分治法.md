#### 1、颠倒给定的 32 位无符号整数的二进制位。

 

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。


进阶:
如果多次调用这个函数，你将如何优化你的算法？

 

示例 1：

```
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```


示例 2：

```
输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```


示例 1：

```
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```


示例 2：

```
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```


提示：

输入是一个长度为 32 的二进制字符串

**题解**——分治法

```c++

class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        //分治法，一直分到最后一层 一组1位 ，然后奇数组和偶数组交换，
        //然后逐层向上,奇数组和偶数组交换
        const uint32_t m1=0x55555555;   //0b 01010101010101010101010101010101
        const uint32_t m2=0x33333333;   //0b 00110011001100110011001100110011
        const uint32_t m4=0x0f0f0f0f;   //0x 00001111000011110000111100001111
        const uint32_t m8=0x00ff00ff;   //0x 00000000111111110000000011111111

        //最后一层
        n = ((n&m1)<<1) | (n>>1&m1);//1位
        //逐层向上
        n = ((n&m2)<<2) | (n>>2&m2);//2位
        n = ((n&m4)<<4) | (n>>4&m4);//4位
        n = ((n&m8)<<8) | (n>>8&m8);//8位
        //第一层 16位
        return n<<16|n>>16;
    }
        
};
```



#### 2、给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。

示例 1:

```
输入: "2-1-1"
输出: [0, 2]
解释: 
((2-1)-1) = 0 
(2-(1-1)) = 2
```


示例 2:

```
输入: "2*3-4*5"
输出: [-34, -14, -10, -10, 10]
解释: 
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
```

##### 题解：分治递归：

对于一个形如` x op y`（op 为运算符，x 和 y 为数） 的算式而言，它的结果组合取决于 x 和 y 的结果组合数，而 x 和 y 又可以写成形如` x op y` 的算式。

因此，该问题的子问题就是 `x op y` 中的 x 和 y：以运算符分隔的左右两侧算式解。

然后我们来进行 分治算法三步走：

分解：按运算符分成左右两部分，分别求解
解决：实现一个递归函数，输入算式，返回算式解
合并：根据运算符合并左右两部分的解，得出最终解

```c++
class Solution {
public:
    vector<int> diffWaysToCompute(string expression) {
        int flag=0;
        vector<int > ans;
        for(int i=0 ;i< expression.length();++i){
            char c=expression[i];  //必须先把字符串中的字符转换 为char 类型
            if(c=='+'||c=='-'||c=='*'){
                flag=1;
                //分解，递归
                //每次都分为 i  和  n-i
                //前 i 的计算结果  和  后n-i 的计算结果 递归得出
                vector<int> left = diffWaysToCompute(expression.substr(0,i));
                vector<int> right = diffWaysToCompute(expression.substr(i+1));
                //合并 将前i 的计算结果 与 后 n-i 的计算结果 进行计算然后加入结果集。
                for(int i:left)
                    for(int j:right){
                        if(c=='+'){ans.emplace_back(i+j);}
                        if(c=='-'){ans.emplace_back(i-j);}
                        if(c=='*'){ans.emplace_back(i*j);}
                    }
            }
        }
        //当分解为 单个字符的时候，返回
        if(flag==0){
            ans.emplace_back(stoi(expression));
        }
        return ans;
    }
};
```

